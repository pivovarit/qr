<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://www.googletagmanager.com 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data:; font-src https://fonts.gstatic.com; connect-src 'self' https://*.google-analytics.com https://*.analytics.google.com https://*.googletagmanager.com;">
    <title>QR Code Generator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1085VCHG37"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-1085VCHG37');
    </script>
    <style>
        :root {
            --bg-primary: #e8eef5;
            --bg-secondary: rgba(255, 255, 255, 0.7);
            --bg-glass: rgba(255, 255, 255, 0.5);
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --text-primary: #1a202c;
            --text-secondary: #4a5568;
            --text-muted: #718096;
            --border-color: rgba(255, 255, 255, 0.6);
            --border-subtle: rgba(0, 0, 0, 0.06);
            --accent: #667eea;
            --accent-hover: #5a67d8;
            --accent-light: rgba(102, 126, 234, 0.15);
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.1);
            --shadow-glow: 0 0 60px rgba(102, 126, 234, 0.4);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 24px;
        }

        body.dark {
            --bg-primary: #0a0a12;
            --bg-secondary: rgba(30, 30, 50, 0.7);
            --bg-glass: rgba(30, 30, 50, 0.5);
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --text-primary: #f7fafc;
            --text-secondary: #a0aec0;
            --text-muted: #718096;
            --border-color: rgba(255, 255, 255, 0.1);
            --border-subtle: rgba(255, 255, 255, 0.05);
            --accent: #818cf8;
            --accent-hover: #a5b4fc;
            --accent-light: rgba(129, 140, 248, 0.2);
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.4);
            --shadow-glow: 0 0 80px rgba(129, 140, 248, 0.35);
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        @keyframes scaleIn {
            0% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes slideUp {
            0% { transform: translateY(10px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            background: #e8eef5;
        }

        html.dark {
            background: #0a0a12;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(-45deg, #e8eef5, #dfe6f0, #e6e0f5, #e0eef5);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            transition: color 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        body.dark {
            background: linear-gradient(-45deg, #0a0a12, #12121f, #0f0a18, #0a1018);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }

        .bg-orb {
            position: fixed;
            border-radius: 50%;
            filter: blur(80px);
            pointer-events: none;
            z-index: 0;
            transition: background 0.3s ease;
        }

        .bg-orb-1 {
            top: -10%;
            right: -5%;
            width: 500px;
            height: 500px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.2));
            animation: float 8s ease-in-out infinite, pulse 4s ease-in-out infinite;
        }

        .bg-orb-2 {
            bottom: -15%;
            left: -10%;
            width: 600px;
            height: 600px;
            background: linear-gradient(135deg, rgba(118, 75, 162, 0.2), rgba(102, 126, 234, 0.15));
            animation: float 10s ease-in-out infinite reverse, pulse 5s ease-in-out infinite;
        }

        .bg-orb-3 {
            top: 40%;
            left: 50%;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.15), transparent);
            animation: float 12s ease-in-out infinite, pulse 6s ease-in-out infinite;
        }

        body.dark .bg-orb-1 {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.15));
        }

        body.dark .bg-orb-2 {
            background: linear-gradient(135deg, rgba(118, 75, 162, 0.15), rgba(102, 126, 234, 0.1));
        }

        body.dark .bg-orb-3 {
            background: radial-gradient(circle, rgba(129, 140, 248, 0.1), transparent);
        }

        .container {
            width: 100%;
            max-width: 900px;
            position: relative;
            z-index: 1;
        }

        .main-layout {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
        }

        .input-column {
            flex: 1;
            min-width: 0;
        }

        .qr-column {
            flex-shrink: 0;
            width: 380px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            animation: slideUp 0.6s ease backwards;
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            background: var(--bg-gradient);
            background-size: 200% 200%;
            animation: gradientShift 5s ease infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 0.95rem;
            animation: slideUp 0.6s ease 0.1s backwards;
        }

        .card {
            background: var(--bg-secondary);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-md), inset 0 1px 1px var(--border-color);
            border: 1px solid var(--border-color);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: slideUp 0.5s ease backwards;
        }

        .card:nth-child(2) { animation-delay: 0.1s; }
        .card:nth-child(3) { animation-delay: 0.2s; }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg), inset 0 1px 1px var(--border-color);
        }

        .card-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
        }

        .preset-selector select {
            width: 100%;
            padding: 0.875rem 1rem;
            font-size: 0.95rem;
            font-weight: 500;
            border: 2px solid var(--border-subtle);
            border-radius: var(--radius-md);
            background-color: var(--bg-glass);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23718096' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.25rem;
            padding-right: 2.5rem;
        }

        .preset-selector select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 4px var(--accent-light), var(--shadow-md);
            transform: translateY(-1px);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        input[type="text"],
        input[type="email"],
        input[type="tel"],
        textarea,
        .input-group select {
            width: 100%;
            padding: 0.875rem 1rem;
            font-size: 0.95rem;
            font-family: inherit;
            border: 2px solid var(--border-subtle);
            border-radius: var(--radius-md);
            background-color: var(--bg-glass);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: var(--text-primary);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        input::placeholder,
        textarea::placeholder {
            color: var(--text-muted);
            transition: all 0.3s ease;
        }

        input:focus::placeholder,
        textarea:focus::placeholder {
            opacity: 0.5;
            transform: translateX(5px);
        }

        input:focus,
        textarea:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 4px var(--accent-light), var(--shadow-md);
            transform: translateY(-1px);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .customization-toggle {
            display: flex;
            justify-content: center;
            margin-bottom: 0.5rem;
        }

        .toggle-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 0.875rem;
            font-size: 0.8rem;
            font-weight: 500;
            font-family: inherit;
            color: var(--text-muted);
            background: var(--bg-glass);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toggle-btn:hover {
            color: var(--text-secondary);
            border-color: var(--border-color);
            background: var(--bg-secondary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }

        .toggle-btn:active {
            transform: translateY(0) scale(0.98);
        }

        .toggle-btn.expanded {
            color: var(--accent);
            background: var(--accent-light);
            border-color: transparent;
        }

        .toggle-btn svg {
            opacity: 0.7;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .toggle-btn:hover svg,
        .toggle-btn.expanded svg {
            opacity: 1;
        }

        .toggle-btn.expanded svg {
            transform: rotate(90deg);
        }

        .toggle-btn .arrow {
            font-size: 0.6rem;
            transition: transform 0.3s ease;
            opacity: 0.6;
        }

        .toggle-btn.expanded .arrow {
            transform: rotate(180deg);
        }

        .customization-panel {
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: transparent;
            border-radius: var(--radius-md);
            margin-bottom: 0;
            border: 1px solid transparent;
        }

        .customization-panel.expanded {
            max-height: 300px;
            padding: 1rem 1.25rem;
            margin-bottom: 1rem;
            border-color: var(--border-color);
            box-shadow: var(--shadow-md);
            background: var(--bg-secondary);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .option-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
        }

        .option-row:first-child {
            padding-top: 0;
        }

        .option-row:last-child {
            padding-bottom: 0;
        }

        .option-row label {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .option-row input[type="color"] {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            padding: 2px;
            background: var(--bg-primary);
            transition: all 0.2s ease;
        }

        .option-row input[type="color"]:hover {
            border-color: var(--text-muted);
        }

        .option-row input[type="range"] {
            width: 100px;
            height: 4px;
            border-radius: 2px;
            background: var(--border-color);
            cursor: pointer;
            -webkit-appearance: none;
        }

        .option-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option-row input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--text-secondary);
        }

        .option-row select {
            padding: 0.35rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--bg-primary);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .option-row select:focus {
            outline: none;
            border-color: var(--text-muted);
        }

        .option-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .size-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .size-value {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-muted);
            min-width: 45px;
            text-align: right;
        }

        #qrcode-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .qr-frame {
            position: relative;
            padding: 2rem;
            background: linear-gradient(145deg, #ffffff, #f0f0f5);
            border-radius: 32px;
            box-shadow:
                var(--shadow-lg),
                var(--shadow-glow),
                inset 0 2px 4px rgba(255,255,255,0.8),
                inset 0 -2px 4px rgba(0,0,0,0.05);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: none;
        }

        .qr-frame.visible {
            display: block;
            animation: scaleIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .qr-frame::before {
            content: '';
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 6px;
            background: linear-gradient(90deg, #e0e0e5, #d0d0d8);
            border-radius: 3px;
        }

        .qr-frame::after {
            content: 'Scan Me';
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #a0a0a8;
        }

        body.dark .qr-frame {
            background: linear-gradient(145deg, #2a2a3e, #1e1e2e);
            box-shadow:
                var(--shadow-lg),
                var(--shadow-glow),
                inset 0 2px 4px rgba(255,255,255,0.05),
                inset 0 -2px 4px rgba(0,0,0,0.2);
        }

        body.dark .qr-frame::before {
            background: linear-gradient(90deg, #3a3a4e, #2a2a3e);
        }

        body.dark .qr-frame::after {
            color: #606070;
        }

        #qrcode {
            background: white;
            padding: 1rem;
            border-radius: var(--radius-md);
            margin-top: 0.5rem;
        }

        #qrcode canvas {
            display: block;
            border-radius: 8px;
        }

        .action-buttons {
            display: none;
            gap: 0.75rem;
            margin-top: 1.5rem;
            width: 100%;
            max-width: 320px;
        }

        .action-buttons.visible {
            display: flex;
            animation: slideUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s backwards;
        }

        .action-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            font-weight: 500;
            font-family: inherit;
            background: var(--bg-secondary);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .action-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: var(--accent-light);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
        }

        .action-btn:hover::before {
            width: 200%;
            height: 200%;
        }

        .action-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .action-btn:active {
            transform: translateY(0) scale(0.98);
        }

        .action-btn .icon {
            font-size: 1.1rem;
            position: relative;
            z-index: 1;
            transition: transform 0.3s ease;
        }

        .action-btn:hover .icon {
            transform: scale(1.2);
        }

        .action-btn span:last-child {
            position: relative;
            z-index: 1;
        }

        .copy-feedback {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--text-primary);
            color: var(--bg-primary);
            padding: 0.875rem 1.5rem;
            border-radius: var(--radius-md);
            font-size: 0.9rem;
            font-weight: 500;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            box-shadow: var(--shadow-lg);
            z-index: 100;
        }

        .copy-feedback.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        footer {
            margin-top: auto;
            padding: 3rem 0 1rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: center;
            position: relative;
            z-index: 1;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
            font-weight: 500;
            transition: opacity 0.2s ease;
        }

        footer a:hover {
            opacity: 0.8;
        }

        .footer-main {
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }

        .footer-lib {
            font-size: 0.75rem;
        }

        @media (max-width: 768px) {
            body {
                padding: 1.5rem 1rem;
            }

            h1 {
                font-size: 1.75rem;
            }

            .main-layout {
                flex-direction: column;
            }

            .qr-column {
                width: 100%;
                order: -1;
                margin-bottom: 1.5rem;
            }

            .card {
                padding: 1.25rem;
            }

            .option-row {
                flex-direction: row;
                justify-content: space-between;
            }

            .option-row input[type="range"] {
                width: 80px;
            }

            .action-buttons {
                flex-direction: row;
                max-width: 100%;
            }

            .qr-frame {
                padding: 1.5rem;
                border-radius: 24px;
            }

            #qrcode {
                padding: 0.75rem;
            }

            .bg-orb {
                opacity: 0.5;
            }

            .bg-orb-1 {
                width: 300px;
                height: 300px;
            }

            .bg-orb-2 {
                width: 350px;
                height: 350px;
            }

            .bg-orb-3 {
                display: none;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 1rem 0.75rem;
            }

            h1 {
                font-size: 1.5rem;
            }

            .subtitle {
                font-size: 0.85rem;
            }

            .header {
                margin-bottom: 1.5rem;
            }

            .card {
                padding: 1rem;
                border-radius: 16px;
                margin-bottom: 0.75rem;
            }

            .card-label {
                font-size: 0.7rem;
                margin-bottom: 0.5rem;
            }

            .preset-selector select,
            input[type="text"],
            input[type="email"],
            input[type="tel"],
            textarea,
            .input-group select {
                padding: 0.75rem 0.875rem;
                font-size: 16px; /* Prevents iOS zoom on focus */
                border-radius: 10px;
            }

            .qr-frame {
                padding: 1.25rem;
                border-radius: 20px;
            }

            .qr-frame::before {
                width: 40px;
                height: 4px;
                top: 10px;
            }

            .qr-frame::after {
                font-size: 0.6rem;
                bottom: 8px;
            }

            #qrcode {
                padding: 0.5rem;
                border-radius: 8px;
            }

            .action-buttons {
                gap: 0.5rem;
                margin-top: 1rem;
            }

            .action-btn {
                padding: 0.875rem 0.75rem;
                font-size: 0.85rem;
                border-radius: 10px;
                min-height: 48px; /* Touch-friendly target size */
            }

            .toggle-btn {
                padding: 0.625rem 1rem;
                font-size: 0.75rem;
                min-height: 40px;
            }

            .customization-panel.expanded {
                padding: 0.875rem 1rem;
            }

            .option-row {
                padding: 0.625rem 0;
            }

            .option-row label {
                font-size: 0.75rem;
            }

            .option-row input[type="color"] {
                width: 36px;
                height: 36px;
                min-width: 36px;
            }

            .option-row input[type="range"] {
                width: 70px;
                height: 6px;
            }

            .option-row input[type="range"]::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }

            .option-row select {
                padding: 0.5rem 0.625rem;
                font-size: 0.75rem;
                min-height: 36px;
            }

            .size-value {
                font-size: 0.75rem;
                min-width: 40px;
            }

            .copy-feedback {
                bottom: 1rem;
                padding: 0.75rem 1.25rem;
                font-size: 0.85rem;
                border-radius: 10px;
                left: 1rem;
                right: 1rem;
                transform: translateY(20px);
                width: auto;
            }

            .copy-feedback.visible {
                transform: translateY(0);
            }

            footer {
                padding: 2rem 0 1rem;
                font-size: 0.75rem;
            }

            .footer-main {
                font-size: 0.85rem;
            }

            .footer-lib {
                font-size: 0.7rem;
            }

            .bg-orb-1,
            .bg-orb-2 {
                opacity: 0.3;
            }
        }

        /* Embed mode - hide UI, show only QR code */
        body.embed-mode {
            background: transparent;
            padding: 0;
            margin: 0;
            min-height: auto;
            animation: none;
        }

        body.embed-mode .bg-orb,
        body.embed-mode .header,
        body.embed-mode .input-column,
        body.embed-mode footer,
        body.embed-mode .action-buttons,
        body.embed-mode .copy-feedback {
            display: none !important;
        }

        body.embed-mode .container {
            max-width: none;
            width: auto;
        }

        body.embed-mode .main-layout {
            gap: 0;
        }

        body.embed-mode .qr-column {
            width: auto;
        }

        body.embed-mode .qr-frame {
            padding: 0;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            margin: 0;
        }

        body.embed-mode .qr-frame::before,
        body.embed-mode .qr-frame::after {
            display: none;
        }

        body.embed-mode #qrcode {
            padding: 0;
            margin: 0;
            border-radius: 0;
            background: transparent;
        }

        body.embed-mode.embed-border #qrcode {
            padding: 1rem;
            border-radius: var(--radius-md);
            background: white;
        }

        /* Ensure proper touch behavior */
        @media (hover: none) and (pointer: coarse) {
            .card:hover {
                transform: none;
            }

            .action-btn:hover::before {
                width: 0;
                height: 0;
            }

            .action-btn:hover {
                transform: none;
            }

            .action-btn:active {
                transform: scale(0.98);
                background: var(--accent-light);
            }

            .toggle-btn:hover {
                transform: none;
            }
        }
    </style>
</head>
<body class="dark">

<div class="bg-orb bg-orb-1"></div>
<div class="bg-orb bg-orb-2"></div>
<div class="bg-orb bg-orb-3"></div>

<div class="container">
    <div class="header">
        <h1>QR Code Generator</h1>
        <p class="subtitle">Create beautiful QR codes instantly</p>
    </div>

    <div class="main-layout">
        <div class="input-column">
            <div class="card preset-selector">
                <div class="card-label">Type</div>
                <select id="presetSelect">
                    <option value="text">Plain Text / URL</option>
                    <option value="wifi">WiFi Network</option>
                    <option value="vcard">Contact Card (vCard)</option>
                    <option value="email">Email Address</option>
                    <option value="sms">SMS Message</option>
                    <option value="phone">Phone Number</option>
                </select>
            </div>

            <div class="card">
                <div class="card-label">Content</div>
                <div class="input-group" id="inputGroup">
                    <input type="text" id="text" placeholder="Enter text or URL..." />
                </div>
            </div>

            <div class="customization-toggle">
                <button type="button" class="toggle-btn" id="panelHeader">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    <span>Options</span>
                    <span class="arrow">â–¼</span>
                </button>
            </div>

            <div class="customization-panel" id="panelContent">
                <div class="option-row">
                    <label for="fgColor">Foreground</label>
                    <input type="color" id="fgColor" value="#000000" />
                </div>
                <div class="option-row">
                    <label for="bgColor">Background</label>
                    <input type="color" id="bgColor" value="#ffffff" />
                </div>
                <div class="option-row">
                    <label for="sizeSlider">Size</label>
                    <div class="size-display">
                        <input type="range" id="sizeSlider" min="128" max="320" value="192" step="32" />
                        <span class="size-value" id="sizeValue">192px</span>
                    </div>
                </div>
                <div class="option-row">
                    <label for="errorLevel">Error Correction</label>
                    <select id="errorLevel">
                        <option value="L">Low (7%)</option>
                        <option value="M">Medium (15%)</option>
                        <option value="Q">Quartile (25%)</option>
                        <option value="H" selected>High (30%)</option>
                    </select>
                </div>
                <div class="option-row">
                    <label for="includeBorder">Include border</label>
                    <input type="checkbox" id="includeBorder" checked />
                </div>
            </div>
        </div>

        <div class="qr-column">
            <div id="qrcode-wrapper">
                <div class="qr-frame" id="qrFrame">
                    <div id="qrcode"></div>
                </div>
                <div class="action-buttons" id="actionButtons">
                    <button class="action-btn" id="downloadBtn">
                        <span class="icon">ðŸ“¥</span>
                        <span>Download</span>
                    </button>
                    <button class="action-btn" id="copyBtn">
                        <span class="icon">ðŸ“‹</span>
                        <span>Copy</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="copy-feedback" id="copyFeedback">Copied to clipboard!</div>

<footer>
    <div class="footer-main">Made with â˜• by <a href="https://github.com/sponsors/pivovarit" target="_blank" rel="noopener">pivovarit</a> â€” <a href="https://github.com/sponsors/pivovarit" target="_blank" rel="noopener">Support on GitHub Sponsors</a> â€” <a href="https://buymeacoffee.com/pivovarit" target="_blank" rel="noopener">Buy Me a Coffee</a></div>
</footer>

<script>
    const QRCode = (function() {
        const ECL = { L: 0, M: 1, Q: 2, H: 3 };

        const EC_CODEWORDS_PER_BLOCK = [
            [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
            [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
            [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
            [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
        ];

        const NUM_EC_BLOCKS = [
            [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
            [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
            [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
            [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
        ];

        const TOTAL_CODEWORDS = [
            -1, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
            1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
        ];

        const ALIGNMENT_PATTERNS = [
            [], [], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34],
            [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62],
            [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90],
            [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118],
            [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146],
            [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]
        ];

        const FORMAT_INFO = [
            [0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976],
            [0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0],
            [0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed],
            [0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b]
        ];

        const VERSION_INFO = [
            0x07c94, 0x085bc, 0x09a99, 0x0a4d3, 0x0bbf6, 0x0c762, 0x0d847, 0x0e60d,
            0x0f928, 0x10b78, 0x1145d, 0x12a17, 0x13532, 0x149a6, 0x15683, 0x168c9,
            0x177ec, 0x18ec4, 0x191e1, 0x1afab, 0x1b08e, 0x1cc1a, 0x1d33f, 0x1ed75,
            0x1f250, 0x209d5, 0x216f0, 0x228ba, 0x2379f, 0x24b0b, 0x2542e, 0x26a64,
            0x27541, 0x28c69
        ];

        const GF = {
            exp: new Uint8Array(512),
            log: new Uint8Array(256),

            init() {
                let x = 1;
                for (let i = 0; i < 255; i++) {
                    this.exp[i] = x;
                    this.log[x] = i;
                    x <<= 1;
                    if (x & 0x100) x ^= 0x11d;
                }
                for (let i = 255; i < 512; i++) {
                    this.exp[i] = this.exp[i - 255];
                }
            },

            mul(a, b) {
                if (a === 0 || b === 0) return 0;
                return this.exp[this.log[a] + this.log[b]];
            },

            polyMul(p1, p2) {
                const result = new Uint8Array(p1.length + p2.length - 1);
                for (let i = 0; i < p1.length; i++) {
                    for (let j = 0; j < p2.length; j++) {
                        result[i + j] ^= this.mul(p1[i], p2[j]);
                    }
                }
                return result;
            },

            polyDiv(dividend, divisor) {
                const result = new Uint8Array(dividend);
                for (let i = 0; i < dividend.length - divisor.length + 1; i++) {
                    if (result[i] !== 0) {
                        const factor = result[i];
                        for (let j = 0; j < divisor.length; j++) {
                            result[i + j] ^= this.mul(divisor[j], factor);
                        }
                    }
                }
                return result.slice(dividend.length - divisor.length + 1);
            },

            generatePoly(degree) {
                let poly = new Uint8Array([1]);
                for (let i = 0; i < degree; i++) {
                    poly = this.polyMul(poly, new Uint8Array([1, this.exp[i]]));
                }
                return poly;
            }
        };

        GF.init();

        function encodeTextToBytes(text) {
            const encoder = new TextEncoder();
            return encoder.encode(text);
        }

        function findMinimumVersion(dataLen, ecl) {
            const capacities = [
                [-1, 17, 32, 53, 78, 106, 134, 154, 192, 230, 271, 321, 367, 425, 458, 520, 586, 644, 718, 792, 858, 929, 1003, 1091, 1171, 1273, 1367, 1465, 1528, 1628, 1732, 1840, 1952, 2068, 2188, 2303, 2431, 2563, 2699, 2809, 2953],
                [-1, 14, 26, 42, 62, 84, 106, 122, 152, 180, 213, 251, 287, 331, 362, 412, 450, 504, 560, 624, 666, 711, 779, 857, 911, 997, 1059, 1125, 1190, 1264, 1370, 1452, 1538, 1628, 1722, 1809, 1911, 1989, 2099, 2213, 2331],
                [-1, 11, 20, 32, 46, 60, 74, 86, 108, 130, 151, 177, 203, 241, 258, 292, 322, 364, 394, 442, 482, 509, 565, 611, 661, 715, 751, 805, 868, 908, 982, 1030, 1112, 1168, 1228, 1283, 1351, 1423, 1499, 1579, 1663],
                [-1, 7, 14, 24, 34, 44, 58, 64, 84, 98, 119, 137, 155, 177, 194, 220, 250, 280, 310, 338, 382, 403, 439, 461, 511, 535, 593, 625, 658, 698, 742, 790, 842, 898, 958, 983, 1051, 1093, 1139, 1219, 1273]
            ];

            for (let v = 1; v <= 40; v++) {
                if (capacities[ecl][v] >= dataLen) return v;
            }
            return -1;
        }

        function calculateDataCapacity(version, ecl) {
            const totalCodewords = TOTAL_CODEWORDS[version];
            const ecCodewordsPerBlock = EC_CODEWORDS_PER_BLOCK[ecl][version];
            const numBlocks = NUM_EC_BLOCKS[ecl][version];
            return totalCodewords - (ecCodewordsPerBlock * numBlocks);
        }

        function encodeDataToCodewords(data, version, ecl) {
            const capacity = calculateDataCapacity(version, ecl);
            const bits = [];

            bits.push(0, 1, 0, 0);

            const countBits = version < 10 ? 8 : 16;
            for (let i = countBits - 1; i >= 0; i--) {
                bits.push((data.length >> i) & 1);
            }

            for (const byte of data) {
                for (let i = 7; i >= 0; i--) {
                    bits.push((byte >> i) & 1);
                }
            }

            const maxBits = capacity * 8;
            for (let i = 0; i < 4 && bits.length < maxBits; i++) {
                bits.push(0);
            }

            while (bits.length % 8 !== 0 && bits.length < maxBits) {
                bits.push(0);
            }

            const padBytes = [0xec, 0x11];
            let padIdx = 0;
            while (bits.length < maxBits) {
                for (let i = 7; i >= 0; i--) {
                    bits.push((padBytes[padIdx] >> i) & 1);
                }
                padIdx = (padIdx + 1) % 2;
            }

            const codewords = new Uint8Array(capacity);
            for (let i = 0; i < capacity; i++) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    byte = (byte << 1) | bits[i * 8 + j];
                }
                codewords[i] = byte;
            }

            return codewords;
        }

        function generateErrorCorrectionCodewords(data, version, ecl) {
            const ecCodewordsPerBlock = EC_CODEWORDS_PER_BLOCK[ecl][version];
            const numBlocks = NUM_EC_BLOCKS[ecl][version];
            const totalCodewords = TOTAL_CODEWORDS[version];
            const dataCapacity = calculateDataCapacity(version, ecl);

            const shortBlockLen = Math.floor(dataCapacity / numBlocks);
            const numLongBlocks = dataCapacity % numBlocks;
            const numShortBlocks = numBlocks - numLongBlocks;

            const generator = GF.generatePoly(ecCodewordsPerBlock);
            const dataBlocks = [];
            const ecBlocks = [];

            let dataIdx = 0;
            for (let i = 0; i < numBlocks; i++) {
                const blockLen = i < numShortBlocks ? shortBlockLen : shortBlockLen + 1;
                const block = data.slice(dataIdx, dataIdx + blockLen);
                dataBlocks.push(block);

                const padded = new Uint8Array(blockLen + ecCodewordsPerBlock);
                padded.set(block);
                const ec = GF.polyDiv(padded, generator);
                ecBlocks.push(ec);

                dataIdx += blockLen;
            }

            const result = new Uint8Array(totalCodewords);
            let idx = 0;

            for (let i = 0; i < shortBlockLen + 1; i++) {
                for (let j = 0; j < numBlocks; j++) {
                    if (i < dataBlocks[j].length) {
                        result[idx++] = dataBlocks[j][i];
                    }
                }
            }

            for (let i = 0; i < ecCodewordsPerBlock; i++) {
                for (let j = 0; j < numBlocks; j++) {
                    result[idx++] = ecBlocks[j][i];
                }
            }

            return result;
        }

        function initializeMatrix(version) {
            const size = version * 4 + 17;
            const matrix = [];
            const reserved = [];
            for (let i = 0; i < size; i++) {
                matrix.push(new Array(size).fill(null));
                reserved.push(new Array(size).fill(false));
            }
            return { matrix, reserved, size };
        }

        function drawFinderPatterns(qr) {
            const { matrix, reserved, size } = qr;
            const pattern = [
                [1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1]
            ];

            const positions = [[0, 0], [0, size - 7], [size - 7, 0]];

            for (const [row, col] of positions) {
                for (let r = 0; r < 7; r++) {
                    for (let c = 0; c < 7; c++) {
                        matrix[row + r][col + c] = pattern[r][c];
                        reserved[row + r][col + c] = true;
                    }
                }
            }

            for (let i = 0; i < 8; i++) {
                if (i < size) {
                    matrix[7][i] = 0; reserved[7][i] = true;
                    matrix[i][7] = 0; reserved[i][7] = true;
                }
                matrix[7][size - 8 + i] = 0; reserved[7][size - 8 + i] = true;
                if (i < 8) {
                    matrix[i][size - 8] = 0; reserved[i][size - 8] = true;
                }
                matrix[size - 8 + i][7] = 0; reserved[size - 8 + i][7] = true;
                if (i < 8) {
                    matrix[size - 8][i] = 0; reserved[size - 8][i] = true;
                }
            }
        }

        function drawAlignmentPatterns(qr, version) {
            if (version < 2) return;

            const { matrix, reserved } = qr;
            const positions = ALIGNMENT_PATTERNS[version];
            const pattern = [
                [1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1],
                [1, 0, 1, 0, 1],
                [1, 0, 0, 0, 1],
                [1, 1, 1, 1, 1]
            ];

            for (const row of positions) {
                for (const col of positions) {
                    if (reserved[row][col]) continue;

                    for (let r = -2; r <= 2; r++) {
                        for (let c = -2; c <= 2; c++) {
                            matrix[row + r][col + c] = pattern[r + 2][c + 2];
                            reserved[row + r][col + c] = true;
                        }
                    }
                }
            }
        }

        function drawTimingPatterns(qr) {
            const { matrix, reserved, size } = qr;

            for (let i = 8; i < size - 8; i++) {
                const bit = (i + 1) % 2;
                if (!reserved[6][i]) {
                    matrix[6][i] = bit;
                    reserved[6][i] = true;
                }
                if (!reserved[i][6]) {
                    matrix[i][6] = bit;
                    reserved[i][6] = true;
                }
            }
        }

        function reserveFormatAndVersionAreas(qr, version) {
            const { matrix, reserved, size } = qr;

            matrix[size - 8][8] = 1;
            reserved[size - 8][8] = true;

            for (let i = 0; i < 9; i++) {
                if (!reserved[8][i]) reserved[8][i] = true;
                if (!reserved[i][8]) reserved[i][8] = true;
            }
            for (let i = 0; i < 8; i++) {
                reserved[8][size - 1 - i] = true;
                reserved[size - 1 - i][8] = true;
            }

            if (version >= 7) {
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 3; j++) {
                        reserved[i][size - 11 + j] = true;
                        reserved[size - 11 + j][i] = true;
                    }
                }
            }
        }

        function writeDataBits(qr, codewords) {
            const { matrix, reserved, size } = qr;
            let bitIdx = 0;
            const totalBits = codewords.length * 8;

            let x = size - 1;
            let upward = true;

            while (x >= 0) {
                if (x === 6) x--;

                for (let i = 0; i < size; i++) {
                    const y = upward ? size - 1 - i : i;

                    for (let dx = 0; dx >= -1; dx--) {
                        const xx = x + dx;
                        if (xx < 0 || reserved[y][xx]) continue;

                        if (bitIdx < totalBits) {
                            const byteIdx = Math.floor(bitIdx / 8);
                            const bitPos = 7 - (bitIdx % 8);
                            matrix[y][xx] = (codewords[byteIdx] >> bitPos) & 1;
                            bitIdx++;
                        } else {
                            matrix[y][xx] = 0;
                        }
                    }
                }

                x -= 2;
                upward = !upward;
            }
        }

        function applyMask(qr, mask) {
            const { matrix, reserved, size } = qr;
            const maskFuncs = [
                (r, c) => (r + c) % 2 === 0,
                (r, c) => r % 2 === 0,
                (r, c) => c % 3 === 0,
                (r, c) => (r + c) % 3 === 0,
                (r, c) => (Math.floor(r / 2) + Math.floor(c / 3)) % 2 === 0,
                (r, c) => (r * c) % 2 + (r * c) % 3 === 0,
                (r, c) => ((r * c) % 2 + (r * c) % 3) % 2 === 0,
                (r, c) => ((r + c) % 2 + (r * c) % 3) % 2 === 0
            ];

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (!reserved[r][c] && maskFuncs[mask](r, c)) {
                        matrix[r][c] ^= 1;
                    }
                }
            }
        }

        function writeFormatInfo(qr, ecl, mask) {
            const { matrix, size } = qr;
            const formatBits = FORMAT_INFO[ecl][mask];

            for (let i = 0; i < 6; i++) {
                matrix[8][i] = (formatBits >> (14 - i)) & 1;
            }
            matrix[8][7] = (formatBits >> 8) & 1;
            matrix[8][8] = (formatBits >> 7) & 1;
            matrix[7][8] = (formatBits >> 6) & 1;
            for (let i = 0; i < 6; i++) {
                matrix[5 - i][8] = (formatBits >> (5 - i)) & 1;
            }

            for (let i = 0; i < 8; i++) {
                matrix[8][size - 1 - i] = (formatBits >> i) & 1;
            }
            for (let i = 0; i < 7; i++) {
                matrix[size - 1 - i][8] = (formatBits >> (14 - i)) & 1;
            }
        }

        function writeVersionInfo(qr, version) {
            if (version < 7) return;

            const { matrix, size } = qr;
            const versionBits = VERSION_INFO[version - 7];

            for (let i = 0; i < 18; i++) {
                const bit = (versionBits >> i) & 1;
                const r = Math.floor(i / 3);
                const c = i % 3;
                matrix[r][size - 11 + c] = bit;
                matrix[size - 11 + c][r] = bit;
            }
        }

        function calculatePenalty(matrix, size) {
            let penalty = 0;

            for (let r = 0; r < size; r++) {
                let runColor = -1;
                let runLen = 0;
                for (let c = 0; c < size; c++) {
                    if (matrix[r][c] === runColor) {
                        runLen++;
                    } else {
                        if (runLen >= 5) penalty += runLen - 2;
                        runColor = matrix[r][c];
                        runLen = 1;
                    }
                }
                if (runLen >= 5) penalty += runLen - 2;
            }

            for (let c = 0; c < size; c++) {
                let runColor = -1;
                let runLen = 0;
                for (let r = 0; r < size; r++) {
                    if (matrix[r][c] === runColor) {
                        runLen++;
                    } else {
                        if (runLen >= 5) penalty += runLen - 2;
                        runColor = matrix[r][c];
                        runLen = 1;
                    }
                }
                if (runLen >= 5) penalty += runLen - 2;
            }

            for (let r = 0; r < size - 1; r++) {
                for (let c = 0; c < size - 1; c++) {
                    const color = matrix[r][c];
                    if (color === matrix[r][c + 1] && color === matrix[r + 1][c] && color === matrix[r + 1][c + 1]) {
                        penalty += 3;
                    }
                }
            }

            const pattern1 = [1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0];
            const pattern2 = [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1];

            for (let r = 0; r < size; r++) {
                for (let c = 0; c <= size - 11; c++) {
                    let match1 = true, match2 = true;
                    for (let i = 0; i < 11; i++) {
                        if (matrix[r][c + i] !== pattern1[i]) match1 = false;
                        if (matrix[r][c + i] !== pattern2[i]) match2 = false;
                    }
                    if (match1 || match2) penalty += 40;
                }
            }

            for (let c = 0; c < size; c++) {
                for (let r = 0; r <= size - 11; r++) {
                    let match1 = true, match2 = true;
                    for (let i = 0; i < 11; i++) {
                        if (matrix[r + i][c] !== pattern1[i]) match1 = false;
                        if (matrix[r + i][c] !== pattern2[i]) match2 = false;
                    }
                    if (match1 || match2) penalty += 40;
                }
            }

            let dark = 0;
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (matrix[r][c] === 1) dark++;
                }
            }
            const percent = (dark * 100) / (size * size);
            const prev5 = Math.floor(percent / 5) * 5;
            const next5 = prev5 + 5;
            penalty += Math.min(Math.abs(prev5 - 50), Math.abs(next5 - 50)) * 2;

            return penalty;
        }

        function cloneMatrix(matrix) {
            return matrix.map(row => [...row]);
        }

        function generate(text, options = {}) {
            const ecl = options.correctLevel !== undefined ? options.correctLevel : ECL.H;
            const data = encodeTextToBytes(text);
            const version = findMinimumVersion(data.length, ecl);

            if (version < 0) {
                throw new Error('Data too long for QR code');
            }

            const dataCodewords = encodeDataToCodewords(data, version, ecl);
            const allCodewords = generateErrorCorrectionCodewords(dataCodewords, version, ecl);

            const qr = initializeMatrix(version);
            drawFinderPatterns(qr);
            drawAlignmentPatterns(qr, version);
            drawTimingPatterns(qr);
            reserveFormatAndVersionAreas(qr, version);
            writeDataBits(qr, allCodewords);

            let bestMask = 0;
            let bestPenalty = Infinity;
            let bestMatrix = null;

            for (let mask = 0; mask < 8; mask++) {
                const testQr = {
                    matrix: cloneMatrix(qr.matrix),
                    reserved: qr.reserved,
                    size: qr.size
                };

                applyMask(testQr, mask);
                writeFormatInfo(testQr, ecl, mask);
                writeVersionInfo(testQr, version);

                const penalty = calculatePenalty(testQr.matrix, testQr.size);
                if (penalty < bestPenalty) {
                    bestPenalty = penalty;
                    bestMask = mask;
                    bestMatrix = testQr.matrix;
                }
            }

            return {
                matrix: bestMatrix,
                size: qr.size,
                version: version
            };
        }

        function renderToCanvas(container, text, options = {}) {
            const width = options.width || 256;
            const height = options.height || 256;
            const colorDark = options.colorDark || '#000000';
            const colorLight = options.colorLight || '#ffffff';

            const qr = generate(text, options);
            const canvasSize = Math.min(width, height);
            const moduleSize = canvasSize / qr.size;
            const offset = (canvasSize - moduleSize * qr.size) / 2;

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = colorLight;
            ctx.fillRect(0, 0, width, height);

            ctx.fillStyle = colorDark;
            for (let r = 0; r < qr.size; r++) {
                for (let c = 0; c < qr.size; c++) {
                    if (qr.matrix[r][c] === 1) {
                        ctx.fillRect(offset + c * moduleSize, offset + r * moduleSize, moduleSize, moduleSize);
                    }
                }
            }

            container.innerHTML = '';
            container.appendChild(canvas);

            const img = document.createElement('img');
            img.src = canvas.toDataURL('image/png');
            img.style.display = 'none';
            container.appendChild(img);
        }

        function QRCode(container, options) {
            if (typeof options === 'string') {
                options = { text: options };
            }

            renderToCanvas(container, options.text, options);
        }

        QRCode.CorrectLevel = ECL;

        return QRCode;
    })();
</script>
<script>
    const presets = {
        text: {
            fields: [
                { id: 'text', type: 'text', placeholder: 'Enter text or URL...' }
            ],
            format: (values) => values.text
        },
        wifi: {
            fields: [
                { id: 'ssid', type: 'text', placeholder: 'Network name (SSID)' },
                { id: 'password', type: 'text', placeholder: 'Password' },
                { id: 'encryption', type: 'select', options: [
                    { value: 'WPA', label: 'WPA/WPA2' },
                    { value: 'WEP', label: 'WEP' },
                    { value: 'nopass', label: 'None' }
                ]}
            ],
            format: (values) => `WIFI:T:${values.encryption};S:${values.ssid};P:${values.password};;`
        },
        vcard: {
            fields: [
                { id: 'name', type: 'text', placeholder: 'Full Name' },
                { id: 'phone', type: 'tel', placeholder: 'Phone Number' },
                { id: 'email', type: 'email', placeholder: 'Email Address' },
                { id: 'org', type: 'text', placeholder: 'Organization (optional)' }
            ],
            format: (values) => {
                let vcard = 'BEGIN:VCARD\nVERSION:3.0\n';
                if (values.name) vcard += `FN:${values.name}\n`;
                if (values.phone) vcard += `TEL:${values.phone}\n`;
                if (values.email) vcard += `EMAIL:${values.email}\n`;
                if (values.org) vcard += `ORG:${values.org}\n`;
                vcard += 'END:VCARD';
                return vcard;
            }
        },
        email: {
            fields: [
                { id: 'emailTo', type: 'email', placeholder: 'Email Address' },
                { id: 'subject', type: 'text', placeholder: 'Subject (optional)' },
                { id: 'body', type: 'textarea', placeholder: 'Message body (optional)' }
            ],
            format: (values) => {
                let mailto = `mailto:${values.emailTo}`;
                const params = [];
                if (values.subject) params.push(`subject=${encodeURIComponent(values.subject)}`);
                if (values.body) params.push(`body=${encodeURIComponent(values.body)}`);
                if (params.length) mailto += '?' + params.join('&');
                return mailto;
            }
        },
        sms: {
            fields: [
                { id: 'smsTo', type: 'tel', placeholder: 'Phone Number' },
                { id: 'smsBody', type: 'text', placeholder: 'Message (optional)' }
            ],
            format: (values) => `smsto:${values.smsTo}:${values.smsBody || ''}`
        },
        phone: {
            fields: [
                { id: 'phoneNumber', type: 'tel', placeholder: 'Phone Number (e.g., +1234567890)' }
            ],
            format: (values) => `tel:${values.phoneNumber}`
        }
    };

    const presetSelect = document.getElementById('presetSelect');
    const inputGroup = document.getElementById('inputGroup');
    const qrContainer = document.getElementById('qrcode');
    const qrFrame = document.getElementById('qrFrame');
    const actionButtons = document.getElementById('actionButtons');
    const downloadBtn = document.getElementById('downloadBtn');
    const copyBtn = document.getElementById('copyBtn');
    const copyFeedback = document.getElementById('copyFeedback');

    const panelHeader = document.getElementById('panelHeader');
    const panelContent = document.getElementById('panelContent');
    const fgColor = document.getElementById('fgColor');
    const bgColor = document.getElementById('bgColor');
    const sizeSlider = document.getElementById('sizeSlider');
    const sizeValue = document.getElementById('sizeValue');
    const errorLevel = document.getElementById('errorLevel');

    panelHeader.addEventListener('click', () => {
        panelHeader.classList.toggle('expanded');
        panelContent.classList.toggle('expanded');
    });

    panelHeader.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') e.preventDefault();
    });

    sizeSlider.addEventListener('input', () => {
        sizeValue.textContent = sizeSlider.value + 'px';
        refreshQRCode();
    });

    function refreshQRCode() {
        if (document.querySelector('#qrcode canvas')) {
            generateQRCode();
        }
    }

    fgColor.addEventListener('input', refreshQRCode);
    bgColor.addEventListener('input', refreshQRCode);
    errorLevel.addEventListener('change', refreshQRCode);

    function createInputFields(presetKey) {
        const preset = presets[presetKey];
        inputGroup.innerHTML = '';

        preset.fields.forEach(field => {
            if (field.type === 'select') {
                const select = document.createElement('select');
                select.id = field.id;
                field.options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value;
                    option.textContent = opt.label;
                    select.appendChild(option);
                });
                select.addEventListener('change', regenerateIfValid);
                inputGroup.appendChild(select);
            } else if (field.type === 'textarea') {
                const textarea = document.createElement('textarea');
                textarea.id = field.id;
                textarea.placeholder = field.placeholder;
                textarea.addEventListener('input', regenerateIfValid);
                inputGroup.appendChild(textarea);
            } else {
                const input = document.createElement('input');
                input.type = field.type;
                input.id = field.id;
                input.placeholder = field.placeholder;
                input.addEventListener('input', regenerateIfValid);
                inputGroup.appendChild(input);
            }
        });

        const firstInput = inputGroup.querySelector('input, textarea');
        if (firstInput) firstInput.focus();

        clearQRCode();
    }

    function collectFormValues() {
        const preset = presets[presetSelect.value];
        const values = {};
        preset.fields.forEach(field => {
            const el = document.getElementById(field.id);
            values[field.id] = el ? el.value.trim() : '';
        });
        return values;
    }

    function isFormValid() {
        const preset = presets[presetSelect.value];
        const values = collectFormValues();

        const firstField = preset.fields[0];
        return values[firstField.id].length > 0;
    }

    function regenerateIfValid() {
        if (isFormValid()) {
            generateQRCode();
        } else {
            clearQRCode();
        }
    }

    function clearQRCode() {
        qrContainer.innerHTML = '';
        qrFrame.classList.remove('visible');
        actionButtons.classList.remove('visible');
    }

    presetSelect.addEventListener('change', () => {
        createInputFields(presetSelect.value);
    });

    function generateQRCode() {
        const preset = presets[presetSelect.value];
        const values = collectFormValues();
        const text = preset.format(values);

        if (!text) return;

        const size = parseInt(sizeSlider.value);
        const errorLevels = {
            'L': QRCode.CorrectLevel.L,
            'M': QRCode.CorrectLevel.M,
            'Q': QRCode.CorrectLevel.Q,
            'H': QRCode.CorrectLevel.H
        };

        qrContainer.innerHTML = '';
        new QRCode(qrContainer, {
            text: text,
            width: size,
            height: size,
            colorDark: fgColor.value,
            colorLight: bgColor.value,
            correctLevel: errorLevels[errorLevel.value]
        });

        if (document.querySelector('#qrcode canvas')) {
            qrFrame.classList.add('visible');
            actionButtons.classList.add('visible');
        }
    }

    const includeBorder = document.getElementById('includeBorder');

    downloadBtn.addEventListener('click', () => {
        const canvas = document.querySelector('#qrcode canvas');
        if (!canvas) return;

        let downloadCanvas = canvas;

        if (includeBorder.checked) {
            const padding = 16;
            const paddedCanvas = document.createElement('canvas');
            paddedCanvas.width = canvas.width + padding * 2;
            paddedCanvas.height = canvas.height + padding * 2;
            const ctx = paddedCanvas.getContext('2d');

            ctx.fillStyle = bgColor.value;
            ctx.fillRect(0, 0, paddedCanvas.width, paddedCanvas.height);
            ctx.drawImage(canvas, padding, padding);

            downloadCanvas = paddedCanvas;
        }

        const link = document.createElement('a');
        link.download = 'qrcode.png';
        link.href = downloadCanvas.toDataURL('image/png');
        link.click();
    });

    copyBtn.addEventListener('click', async () => {
        const canvas = document.querySelector('#qrcode canvas');
        if (!canvas) return;

        let copyCanvas = canvas;

        if (includeBorder.checked) {
            const padding = 16;
            const paddedCanvas = document.createElement('canvas');
            paddedCanvas.width = canvas.width + padding * 2;
            paddedCanvas.height = canvas.height + padding * 2;
            const ctx = paddedCanvas.getContext('2d');

            ctx.fillStyle = bgColor.value;
            ctx.fillRect(0, 0, paddedCanvas.width, paddedCanvas.height);
            ctx.drawImage(canvas, padding, padding);

            copyCanvas = paddedCanvas;
        }

        if (!navigator.clipboard?.write || !window.ClipboardItem) {
            copyFeedback.textContent = 'Copy not supported in this browser';
            copyFeedback.classList.add('visible');
            setTimeout(() => {
                copyFeedback.textContent = 'Copied to clipboard!';
                copyFeedback.classList.remove('visible');
            }, 3000);
            return;
        }

        try {
            const clipboardItem = new ClipboardItem({
                'image/png': new Promise((resolve, reject) => {
                    copyCanvas.toBlob((blob) => {
                        if (blob) resolve(blob);
                        else reject(new Error('Failed to create blob'));
                    }, 'image/png');
                })
            });
            await navigator.clipboard.write([clipboardItem]);

            copyFeedback.classList.add('visible');
            setTimeout(() => {
                copyFeedback.classList.remove('visible');
            }, 2000);
        } catch (err) {
            console.error('Clipboard error:', err);
            copyFeedback.textContent = 'Copy failed - try Download instead';
            copyFeedback.classList.add('visible');
            setTimeout(() => {
                copyFeedback.textContent = 'Copied to clipboard!';
                copyFeedback.classList.remove('visible');
            }, 3000);
        }
    });

    createInputFields('text');

    function initFromUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const urlParam = params.get('url');

        if (!urlParam) return;

        const isEmbed = params.get('embed') === 'true' || params.get('embed') === '1';
        const hasBorder = params.get('border') !== 'false' && params.get('border') !== '0';

        if (isEmbed) {
            document.body.classList.add('embed-mode');
            if (hasBorder) {
                document.body.classList.add('embed-border');
            }
        }

        if (params.get('fg')) {
            const fg = params.get('fg');
            fgColor.value = fg.startsWith('#') ? fg : '#' + fg;
        }
        if (params.get('bg')) {
            const bg = params.get('bg');
            bgColor.value = bg.startsWith('#') ? bg : '#' + bg;
        }
        if (params.get('size')) {
            const size = parseInt(params.get('size'));
            if (size >= 128 && size <= 320) {
                sizeSlider.value = size;
                sizeValue.textContent = size + 'px';
            }
        }
        if (params.get('ecl')) {
            const ecl = params.get('ecl').toUpperCase();
            if (['L', 'M', 'Q', 'H'].includes(ecl)) {
                errorLevel.value = ecl;
            }
        }

        const textInput = document.getElementById('text');
        if (textInput) {
            textInput.value = urlParam;
            generateQRCode();

            if (isEmbed && hasBorder) {
                qrContainer.style.backgroundColor = bgColor.value;
            }
        }
    }

    initFromUrlParams();
</script>
</body>
</html>
